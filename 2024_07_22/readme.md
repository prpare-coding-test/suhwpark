## 수_고르기_2230
### 소요시간
1시간... 투포인터 개념을 까먹어서 복기하고 풀었슴당

### 간단 풀이 방법
투 포인터 개념을 사용하였다.
index i를 1번으로 지정하고, j는 0번으로 지정하여, arr[i] - arr[j] >= M 까지 i의 인덱스를 증가시킨다
ex) 1 1 1 1 1 1 2 4 5 8 9  (M = 5)
i는 arr[i] = 8 까지 증감 cuz, 8 - 1 > M
이때 answer = 7
1 1 1 1 1 1 2 4 5 8 9 (1번째 j 증감)
  j               i
...
1 1 1 1 1 1 2 4 5 8 9 (6번째 j 증감)
            j     i
answer = 6 (8 - 6)
1 1 1 1 1 1 2 4 5 8 9 (7번째 j 증감)
              j   i
i++
1 1 1 1 1 1 2 4 5 8 9 (6번째 j 증감)
              j     i
9 - 4 = 5 (정답)
이런 식으로 index를 두개 놓고 M보다 클때까지의 기준을 설정한후 최솟값을 움직이면서 정답을 도출하기로했다.

### pseudo code
```java
while (i < N) {
    if (arr[i] - arr[j] < M) {
        i++;
        continue;
    }
    if (arr[i] - arr[j] == M) {
        answer = M;
        break ;
    }
    answer = Math.min(answer, arr[i] - arr[j]);
    j++;
}
```

### 메모리 및 시간
- 27692kb
- 384ms

## 부분_합_1806
### 소요시간
1시간 30분 (너무 어려웠다)

### 간단 풀이 방법
예제에 관해서
[X, 5, 1, 3, 5, 10, 7, 4, 9, 2, 8] 에 대한 부분 합 배열에서 index 5, 3에 관한 합을 구하자면
[0, 5, 6, 9, 14, 24, 31, 35, 44, 46, 54]
                  5
          3
index 5까지의 합 24, index 3까지의 합 9
두 부분합이 공유하는 합은 index 2까지이다
즉, 24 - 6 = 18이 된다
이 방식으로 S >= 부분 합 이 될때, 최솟값의 길이를 구한다.

### pseudo code
```java
while (i < N + 1 && j < N + 1) {
    if (prefix[i] - prefix[j - 1] < S) {
        i++;
        continue;
    }
    answer = Math.min(answer, i - j + 1);
    j++;
    i = j;
}
```
### 메모리 및 시간
- 24412kb
- 828ms