## 내리막_길_1520
### 소요 시간
1시간 (백트래킹으로 풀었다가,,, 시간 초과...)

### 간단 풀이 방법
각 좌표에 도달할 수 있는 경우의 수를 저장하는 dp 배열 선언 후 재귀를 통해 경우의 수를 메모한다
dp[y][x] != -1 일 경우는 경우의 수가 이미 있는 것이니 그 값을 반환
-1 이면 방문하지 않았기에, 0으로 값을 설정하고, 4방향으로 이동할 수 있는 경우 이동하여 경우의 수를 구한다
map 끝에 도달했을 경우, 1을 반환한다.

### pseudo code 
```java
if (y == M - 1 && x == N - 1) {
    return 1;
}

if (dp[y][x] != -1) {
    return dp[y][x];
}

dp[y][x] = 0;
for (int i = 0; i < 4; ++i) {
    int ny = y + dy[i];
    int nx = x + dx[i];

    if (ny < 0 || ny >= M || nx < 0 || nx >= N) {
        continue;
    }
    if (map[y][x] > map[ny][nx] ) {
        dp[y][x] += getCount(ny, nx);
    }
}
return dp[y][x];
```

### 메모리 및 시간
- 41804kb
- 380ms

## 가장_큰_정사각형_1915
### 소요시간
30분

### 간단 풀이 방법
대표적인 dp문제
자신의 위치에서 왼쪽 위쪽 대각선의 값중 가장 작은 값 + 1이 구할 수 있는 정사각형의 한 변의 길이
map을 순회하면서, 각 위치에서 만들수 있는 가장 큰 정사각형의 한 변의 길이를 메모한다.
0 1
1 1
의 현위치가 (1, 1)이라고 한다면, 현 위치의 대각선, 왼쪽, 위쪽의 가장 작은 값을 구하고 +1을 해주면 내 위치에서 구할 수 있는
가장 큰 정사각형의 한변의 길이를 구할 수 있다
1 1
1 1
의 board 라면 dp는
1 1
1 2
이렇게 될것이다
1 1 1
1 1 1
1 1 1
의 board 라면
1 1 1
1 2 2
1 2 3
이렇게 되어 한변의 길이가 3인 정사각형을 구할 수 있다!

### psuedo code
```java
for (int i = 0 ; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
        dp[i][j] = map[i][j];

        if (i != 0 && j != 0 && dp[i][j] != 0) {
            dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
        }

        max = Math.max(max, dp[i][j]);
    }
}
```

### 메모리 및 시간
- 105484kb
- 804ms

## 팰린드롬_10942
### 소요 시간
1시간 반

### 간단 풀이 방법
인덱스 별로 시작값과 끝값에 대해 펠린드롬을 구하여 dp[s][e] 에 저장한다
펠린드롬으로 판단하는 3가지 기준
1. 길이가 1일 경우
2. 길이가 2일 경우, 배열의 모든 요소가 같은 값일 때
3. 길이가 3이상 일 경우, 배열의 시작 인덱스 값과 끝 인덱스 값이 일치하고, 시작 + 1 인덱스 부터, 끝 - 1 인덱스의 값이 펠린드롬일 경우

### pseudo code
```java
// 길이가 1이면 모든 배열은 펠린드롬이다
// 1 2 3 4 5 이런거 다...
for (int i = 1; i <= N; ++i) {
    dp[i][i] = 1;
}

// 길이가 2일 때 각 요소가 같은 경우 펠린드롬이다
// 1 1, 2 2, 3 3, 4 4,
for (int i = 1; i < N; ++i) {
    if (arr[i] == arr[i + 1]) {
        dp[i][i + 1] =  1;
    }
}

//길이가 3이상 일 경우
// 인덱스 시작과 끝 값이 같아야한다. 1, ..... ,1
// 인덱스 시작 + 1 부터 인덱스 끝 - 1 이 펠린드롬이여야한다.
// 1, 2, 1, 2, 1 이런 식의 배열
for (int i = 2; i < N; ++i) {
    for (int j = 1; j  <= N - i; ++j) {
        if (arr[j] == arr[j + i] && dp[j + 1][j + i - 1] == 1) {
            dp[j][j + i] = 1;
        }
    }
}
```

### 메모리 및 시간
- 305472kb
- 896ms